---
import type { CounterMap, Language } from '@root/sanity/sanity.types';
import sanityClient from '@root/sanity/sanity.cli';
import { definedLocalisedSlug, definedMapAsset } from '@lib/groqUtils';
import { DEFAULT_LANGUAGE_ID } from '@lib/languageUtils';
import { fetchSvg } from '@lib/imageUtils';
import { getDate, getPreferredSlug, getTitle, type DateObject } from '@lib/contentUtils';
import SuperposedContent from '@components/SuperposedContent.astro';
import { generateRoute } from '@lib/routingUtils';

const doc: (CounterMap & {
    mapAssetUrl?: string | undefined;
    mapAssetWidth?: number | undefined;
    mapAssetHeight?: number | undefined;
}) | undefined = await sanityClient.fetch(`
    *[_type == 'specialProject_counterMap' && (${definedLocalisedSlug}) && (${definedMapAsset})][0] {
        title,
        date,
        'mapAssetUrl': mapAsset.asset->url,
        'mapAssetWidth': mapAsset.asset->metadata.dimensions.width,
        'mapAssetHeight': mapAsset.asset->metadata.dimensions.height,
        mapMarkers[] {
            x,
            y,
            initiative->{
                _type,
                title,
                slug
            }
        }
    }
`);

type Props = {
    lang: Language | undefined;
    exitPathname: string | undefined;
};

const {
    lang = DEFAULT_LANGUAGE_ID,
    exitPathname,
} = Astro.props;

const resolvedTitle = doc && getTitle(doc, lang);
const resolvedDate: DateObject = {
    iso: doc && 'date' in doc ? getDate(doc, 'iso', lang) : undefined,
    compact: doc && 'date' in doc ? getDate(doc, 'compact', lang) : undefined,
    readable: doc && 'date' in doc ? getDate(doc, 'readable', lang) : undefined,
};

const hasMapAsset = !!(
    doc?.mapAssetUrl
    && typeof doc.mapAssetWidth === 'number'
    && !isNaN(doc.mapAssetWidth)
    && typeof doc.mapAssetHeight === 'number'
    && !isNaN(doc.mapAssetHeight)
);

const svgContent = hasMapAsset && await fetchSvg(doc.mapAssetUrl, false);
---

<div>
    <SuperposedContent
        lang={lang}
        title={resolvedTitle}
        date={resolvedDate && {
            iso: resolvedDate.iso,
            compact: resolvedDate.compact,
            readable: resolvedDate.readable,
        } || undefined}
        exitPathname={exitPathname}
    >
        <div id='counter-map' transition:persist='counter-map'>
            {svgContent && (
                <svg viewBox={`0 0 ${doc.mapAssetWidth} ${doc.mapAssetHeight}`} xmlns='http://www.w3.org/2000/svg'>
                    <g id='counter-map-asset'>
                        <Fragment set:html={svgContent.replace(/\s*(viewBox)\s*=\s*(['"])[\s\S]*?\2/gi, '')} />
                    </g>
                    {Array.isArray(doc.mapMarkers) && doc.mapMarkers.filter((marker) => {
                        return marker
                        && typeof marker.x === 'number'
                        && !isNaN(marker.x)
                        && typeof marker.y === 'number'
                        && !isNaN(marker.y) ? true : false;
                    }).length !== 0 && (
                        <g id='counter-map-markers'>
                            {doc.mapMarkers.map((marker, index) => {
                                const initiative = marker.initiative;
                                const slugData = getPreferredSlug(initiative, lang);
                                const initiativeTitle = getTitle(initiative, slugData?.langUsed);
                                const routeToInitiative = generateRoute(initiative, slugData?.langUsed);
                                return marker.x && marker.y && (
                                    <a
                                        class={`marker-${routeToInitiative ? 'enabled' : 'disabled'}`}
                                        href={routeToInitiative}
                                        title={initiativeTitle}
                                        data-action={routeToInitiative ? 'open-windowed-content' : undefined}
                                        data-action-target-lang={routeToInitiative ? lang : undefined}
                                        data-action-target-type={marker?.initiative?._type ?? undefined}
                                        data-action-target-pathname={routeToInitiative}
                                    >
                                        <circle
                                            cx={marker.x / 100 * doc.mapAssetWidth!}
                                            cy={marker.y / 100 * doc.mapAssetHeight!}
                                            r='1.75rem'
                                        />
                                        <text
                                            x={marker.x / 100 * doc.mapAssetWidth!}
                                            y={marker.y / 100 * doc.mapAssetHeight!}
                                            text-anchor='middle'
                                            dominant-baseline='central'
                                        >
                                            {index + 1}
                                        </text>
                                    </a>
                                );
                            })}
                        </g>
                    )}
                </svg>
            )}
        </div>
        {/* <div slot='in-orbs'>
            <a href='#information'>
                Orb
            </a>
        </div> */}
    </SuperposedContent>
</div>

<script>
    import svgPanZoom from 'svg-pan-zoom';
    import Hammer from 'hammerjs';

    const initPanZoom = () => {
        const counterMapContainer: HTMLElement | null = document.querySelector('#counter-map');
        const counterMapSvg = counterMapContainer?.querySelector('svg');

        if (!counterMapContainer || !counterMapSvg) return;

        // Declare parameters
        const FIT = true;
        const GUTTER_WIDTH = 300;
        const GUTTER_HEIGHT = 300;
        const MIN_ZOOM = 1;
        const MAX_ZOOM = 5;
        const ZOOM_SENSITIVITY = 0.2;
        let isDragging = false;

        // Create an instance of svgPanZoom
        const panZoomInstance = svgPanZoom(counterMapSvg, {
            fit: FIT,
            contain: !FIT,
            center: true,
            panEnabled: true,
            zoomEnabled: true,
            controlIconsEnabled: false,
            dblClickZoomEnabled: true,
            mouseWheelZoomEnabled: true,
            preventMouseEventsDefault: false,
            zoomScaleSensitivity: ZOOM_SENSITIVITY,
            minZoom: MIN_ZOOM,
            maxZoom: MAX_ZOOM,
            customEventsHandler: {
                haltEventListeners: [
                    'touchstart',
                    'touchend',
                    'touchmove',
                    'touchleave',
                    'touchcancel',
                ],
                init: function(this: any, options) {
                    const instance = options.instance;
                    let initialScale = 1;
                    let pannedX = 0;
                    let pannedY = 0;
                    this.hammer = new Hammer(options.svgElement, {
                        // @ts-ignore
                        inputClass: Hammer.SUPPORT_POINTER_EVENTS
                            ? Hammer.PointerEventInput
                            : Hammer.TouchInput,
                    });
                    this.hammer.get('pinch').set({ enable: true });
                    this.hammer.on('doubletap', function () {
                        instance.zoomIn();
                    });
                    this.hammer.on('panstart panmove', function (event: HammerInput) {
                        if (event.type === 'panstart') {
                            pannedX = 0;
                            pannedY = 0;
                        }
                        instance.panBy({ x: event.deltaX - pannedX, y: event.deltaY - pannedY });
                        pannedX = event.deltaX;
                        pannedY = event.deltaY;
                    });
                    this.hammer.on('pinchstart pinchmove', function (event: HammerInput) {
                        if (event.type === 'pinchstart') {
                            initialScale = instance.getZoom();
                        }
                        instance.zoomAtPoint(initialScale * event.scale, {
                            x: event.center.x,
                            y: event.center.y,
                        });
                    });
                    options.svgElement.addEventListener('touchmove', function (e) {
                        e.preventDefault();
                    });
                },
                destroy: function(this: any) {
                    if (this.hammer) {
                        this.hammer.destroy();
                    }
                },
            },
        });

        // Limit panning
        interface Point {
            x: number;
            y: number;
        };
        const beforePan = (_oldPan: Point, newPan: Point) => {
            const sizes = panZoomInstance.getSizes();
            const leftLimit = -((sizes.viewBox.x + sizes.viewBox.width) * sizes.realZoom) + GUTTER_WIDTH;
            const rightLimit = sizes.width - GUTTER_WIDTH - (sizes.viewBox.x * sizes.realZoom);
            const topLimit = -((sizes.viewBox.y + sizes.viewBox.height) * sizes.realZoom) + GUTTER_HEIGHT;
            const bottomLimit = sizes.height - GUTTER_HEIGHT - (sizes.viewBox.y * sizes.realZoom);
            const customPan: Point = {
                x: 0,
                y: 0,
            };
            customPan.x = Math.max(leftLimit, Math.min(rightLimit, newPan.x));
            customPan.y = Math.max(topLimit, Math.min(bottomLimit, newPan.y));
            return customPan;
        };
        panZoomInstance.setBeforePan(beforePan);

        // Add 'grabbing' cursor effect
        counterMapContainer.addEventListener('mousedown', () => {
            isDragging = true;
            counterMapContainer.style.cursor = 'grabbing';
        });
        counterMapContainer.addEventListener('mouseup', () => {
            if (!isDragging) return;
            isDragging = false;
            counterMapContainer.style.removeProperty('cursor');
        });

        // Enable pinch zooming
        // TODO
    };

    initPanZoom();
    document.addEventListener('astro:after-swap', initPanZoom);
</script>

<style lang='scss'>
    #counter-map {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--counter-map-viewport-background-colour);
        overflow: hidden;
        touch-action: none;
    }
    #counter-map > :global(svg) {
        display: block;
        height: 100%;
        width: 100%;
    }
    #counter-map-asset > :global(*) {
        vector-effect: initial !important;
    }
    #counter-map-markers circle {
        stroke-width: 1px;
    }
    #counter-map-markers text {
        font-weight: 400;
    }
    .marker-enabled {
        fill: var(--counter-map-marker-enabled-background-colour);
        stroke: var(--counter-map-marker-outline-colour);
    }
    .marker-enabled text {
        fill: var(--counter-map-marker-enabled-foreground-colour);
    }
    .marker-disabled {
        pointer-events: none;
        fill: var(--counter-map-marker-disabled-background-colour);
        stroke: var(--counter-map-marker-outline-colour);
    }
    .marker-disabled text {
        fill: var(--counter-map-marker-disabled-foreground-colour);
    }
    @media (any-hover: hover) {
        .marker-enabled:hover text {
            fill: var(--counter-map-marker-hover-foreground-colour);
        }
    }
</style>